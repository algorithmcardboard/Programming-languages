%{
#include <iostream>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    int val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog

%token PLUS MINUS MUL DIV
%token <val> NUM    /* 'val' is the (only) field declared in %union
                       which represents the type of the token. */

%type <val> expr

%%

prog : expr                             { std::cout << $1 << std::endl; }
     ;

expr : PLUS NUM expr                     { std::cout << "$2 is " << $2 << " $3 is " << $3 << std::endl; $$ = $2 + $3; }
     | PLUS NUM NUM                      { std::cout << "matching second rule " << std::endl; $$ = $2 + $3; }
     | NUM expr                          { std::cout << "matching third rule " << std::endl; $$ = $1 + $2; }
     | NUM NUM                           { std::cout << "matching fourth rule " << std::endl; $$ = $1 + $2; }

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}

